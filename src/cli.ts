#!/usr/bin/env node

import * as fs from 'node:fs'
import * as path from 'node:path'
import { fileURLToPath } from 'node:url'
import { program } from 'commander'
import { transpile, transpileText } from './transpiler/index.js'
import { SourceCodeLocation, WorkflowSyntaxError } from './errors.js'
import { TSError } from '@typescript-eslint/typescript-estree'

interface CLIOptions {
  project?: string
  outdir?: string
  link: boolean
  generatedFileComment: boolean
}

interface Input {
  filename?: string
  read: () => string
}

function parseArgs() {
  program
    .name('ts2workflow')
    .version(versionFromPackageJson())
    .description(
      'Transpile a Typescript program into GCP Workflows YAML syntax.',
    )
    .option(
      '--project <path>',
      'Path to TSConfig for the Typescript sources files.',
    )
    .option(
      '--outdir <path>',
      'Specify an output directory for where transpilation result are written.',
    )
    .option(
      '--link',
      'Emit YAML that includes all necessary subworkflows in one file. Requires --project',
      false,
    )
    .option(
      '--generated-file-comment',
      'Include a comment stating that the result is a generated file',
      true,
    )
    .option(
      '--no-generated-file-comment',
      "Don't include a comment about file being generated",
    )
    .argument(
      '[FILES...]',
      'Path to source file(s) to compile. If not given, reads from stdin.',
    )
    .parse()

  const opts = program.opts<CLIOptions>()
  if (opts.link && !opts.project) {
    console.warn('--link must be used together with --project')
  }

  return {
    ...opts,
    sourceFiles: program.args,
  }
}

function cliMain() {
  const args = parseArgs()

  let files = []
  if (args.sourceFiles.length === 0) {
    files = ['-']
  } else {
    files = args.sourceFiles
  }

  files.forEach((inputFile) => {
    const input = readSourceCode(inputFile)

    try {
      const transpiled = generateTranspiledText(
        input,
        args.generatedFileComment,
        args.link,
        args.project,
      )

      writeOutput(transpiled, inputFile, args.outdir)
    } catch (err) {
      if (isIoError(err)) {
        let message: string
        if ('code' in err && err.code === 'EAGAIN' && inputFile === '-') {
          // Reading from stdin if there's no input causes error. This is a bug in node
          message = 'Error: Failed to read from stdin'
        } else if ('code' in err && err.code === 'EISDIR') {
          message = `Error: "${inputFile}" is a directory`
        } else {
          message = err.message
        }
        console.error(message)
        process.exit(1)
      } else if (err instanceof WorkflowSyntaxError) {
        prettyPrintSyntaxError(err, input)
        process.exit(1)
      } else if (err instanceof TSError) {
        prettyPrintSyntaxError(err, input)
        process.exit(1)
      } else {
        throw err
      }
    }
  })
}

function generateTranspiledText(
  input: Input,
  addGeneratedFileComment: boolean,
  linkSubworkflows: boolean,
  project?: string,
): string {
  if (input.filename === undefined) {
    return transpileText(input.read())
  } else {
    const header = addGeneratedFileComment
      ? generatedFileComment(input.filename)
      : ''
    const transpiled = transpile(input, project, linkSubworkflows)
    return `${header}${transpiled}`
  }
}

function readSourceCode(filename: string): Input {
  const readCode = crateMemorizedReader(
    filename === '-' ? process.stdin.fd : filename,
  )

  return {
    filename: filename === '-' ? undefined : filename,
    read: () => readCode(),
  }
}

function crateMemorizedReader(filenameOrFd: string | number): () => string {
  let cached: string | undefined

  return () => {
    cached ??= fs.readFileSync(filenameOrFd, 'utf8')
    return cached
  }
}

function writeOutput(
  transpiled: string,
  inputFile: string,
  outdir?: string,
): void {
  if (outdir !== undefined) {
    if (!fs.existsSync(outdir)) {
      fs.mkdirSync(outdir, { recursive: true })
    }

    const outputFile = createOutputFilename(inputFile, outdir)
    fs.writeFileSync(outputFile, transpiled)
  } else {
    process.stdout.write(transpiled)
  }
}

function createOutputFilename(inputFile: string, outdir: string): string {
  const parsedInput = path.parse(inputFile)

  return path.format({
    dir: outdir,
    name: parsedInput.name,
    ext: '.yaml',
  })
}

function generatedFileComment(inputFile: string): string {
  return (
    `# This file has been generated by "ts2workflows ${inputFile}"\n` +
    '# Do not edit!\n\n'
  )
}

function isIoError(err: unknown): err is Error {
  return err instanceof Error && 'code' in err
}

function prettyPrintSyntaxError(
  exception: WorkflowSyntaxError,
  inp: Input,
): void {
  console.error(errorDisplay(inp, exception.location))
  console.error(`${exception.message}`)
}

function errorDisplay(
  inp: Input,
  location: SourceCodeLocation | undefined,
): string {
  const lines: string[] = []
  const prettyFilename = inp.filename ?? '<stdin>'
  if (
    typeof location?.start === 'undefined' ||
    typeof location?.end === 'undefined' ||
    isNaN(location?.start.line) ||
    isNaN(location?.end.line)
  ) {
    lines.push(`File ${prettyFilename}:`)
  } else {
    lines.push(
      `File ${prettyFilename}, line ${location.start.line}, column ${location.start.column + 1}:`,
    )
  }

  const highlightedLine = highlightedSourceCodeLine(
    inp.read(),
    location?.start?.line,
    location?.start?.column,
    location?.start?.line === location?.end?.line
      ? location?.end?.column
      : undefined,
  )
  if (highlightedLine.length > 0) {
    lines.push(highlightedLine)
    lines.push('')
  }

  return lines.join('\n')
}

function highlightedSourceCodeLine(
  sourceCode: string,
  lineNumber?: number,
  start?: number,
  end?: number,
): string {
  if (
    typeof lineNumber === 'undefined' ||
    typeof start === 'undefined' ||
    isNaN(start)
  ) {
    return ''
  }

  const lines = sourceCode.split('\n')
  const sourceLine = lines[lineNumber - 1]
  if (typeof sourceLine === 'undefined') {
    return ''
  }

  let markerLength
  if (typeof end === 'undefined') {
    markerLength = sourceLine.length - start
  } else {
    markerLength = Math.min(end - start + 1, sourceLine.length - start)
  }

  const markerLine = `${' '.repeat(start)}${'^'.repeat(markerLength)}`

  return `${sourceLine}\n${markerLine}`
}

function versionFromPackageJson(): string {
  const currentFile = fileURLToPath(import.meta.url)
  const currentDir = path.dirname(currentFile)
  const packagePath = path.join(currentDir, '..', 'package.json')
  const pjson = JSON.parse(fs.readFileSync(packagePath, 'utf-8')) as {
    version?: string
  }
  return pjson.version ?? '???'
}

if (
  import.meta.url.endsWith(process.argv[1]) ||
  process.argv[1].endsWith('/ts2workflows')
) {
  cliMain()
}
