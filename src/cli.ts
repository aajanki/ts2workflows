#!/usr/bin/env node

import * as fs from 'node:fs'
import * as path from 'node:path'
import { fileURLToPath } from 'node:url'
import { program } from 'commander'
import { transpile } from './transpiler/index.js'
import { SourceCodeLocation, WorkflowSyntaxError } from './errors.js'
import { TSError } from '@typescript-eslint/typescript-estree'

interface CLIOptions {
  project?: string
  outdir?: string
  generatedFileComment: boolean
}

function parseArgs() {
  program
    .name('ts2workflow')
    .version(versionFromPackageJson())
    .description(
      'Transpile a Typescript program into GCP Workflows YAML syntax.',
    )
    .option(
      '--project <path>',
      'Path to TSConfig for the Typescript sources files.',
    )
    .option(
      '--outdir <path>',
      'Specify an output directory for where transpilation result are written.',
    )
    .option(
      '--generated-file-comment',
      'Include a comment stating that the result is a generated file',
      true,
    )
    .option(
      '--no-generated-file-comment',
      "Don't include a comment about file being generated",
    )
    .argument(
      '[FILES...]',
      'Path to source file(s) to compile. If not given, reads from stdin.',
    )
    .parse()

  return {
    ...program.opts<CLIOptions>(),
    sourceFiles: program.args,
  }
}

function cliMain() {
  const args = parseArgs()

  let files = []
  if (args.sourceFiles.length === 0) {
    files = ['-']
  } else {
    files = args.sourceFiles
  }

  files.forEach((inputFile) => {
    try {
      const transpiled = generateTranspiledText(
        inputFile,
        args.generatedFileComment,
        args.project,
      )

      if (transpiled === undefined) {
        process.exit(1)
      }

      writeOutput(transpiled, inputFile, args.outdir)
    } catch (err) {
      if (isIoError(err, 'ENOENT') && isIoError(err, 'EACCES')) {
        console.error(err.message)
        process.exit(1)
      } else if (isIoError(err, 'EISDIR')) {
        console.error(`Error: "${inputFile}" is a directory`)
        process.exit(1)
      } else if (isIoError(err, 'EAGAIN') && inputFile === '-') {
        // Reading from stdin if there's no input causes error. This is a bug in node
        console.error('Error: Failed to read from stdin')
        process.exit(1)
      } else {
        throw err
      }
    }
  })
}

function generateTranspiledText(
  inputFile: string,
  addGeneratedFileComment: boolean,
  project?: string,
): string | undefined {
  const inputIsStdIn = inputFile === '-'
  const inp = inputIsStdIn ? process.stdin.fd : inputFile
  const sourceCode = fs.readFileSync(inp, 'utf8')

  try {
    const needsHeader = addGeneratedFileComment && !inputIsStdIn
    const header = needsHeader ? generatedFileComment(inputFile) : ''
    const transpiled = transpile(sourceCode, inputFile, project)
    return `${header}${transpiled}`
  } catch (err) {
    if (err instanceof WorkflowSyntaxError) {
      prettyPrintSyntaxError(err, inputFile, sourceCode)
      return undefined
    } else if (err instanceof TSError) {
      prettyPrintSyntaxError(err, inputFile, sourceCode)
      return undefined
    } else {
      throw err
    }
  }
}

function writeOutput(
  transpiled: string,
  inputFile: string,
  outdir?: string,
): void {
  if (outdir !== undefined) {
    if (!fs.existsSync(outdir)) {
      fs.mkdirSync(outdir, { recursive: true })
    }

    const outputFile = createOutputFilename(inputFile, outdir)
    fs.writeFileSync(outputFile, transpiled)
  } else {
    process.stdout.write(transpiled)
  }
}

function createOutputFilename(inputFile: string, outdir: string): string {
  const parsedInput = path.parse(inputFile)

  return path.format({
    dir: outdir,
    name: parsedInput.name,
    ext: '.yaml',
  })
}

function generatedFileComment(inputFile: string): string {
  return (
    `# This file has been generated by "ts2workflows ${inputFile}"\n` +
    '# Do not edit!\n\n'
  )
}

function isIoError(err: unknown, errorCode: string): err is Error {
  return err instanceof Error && 'code' in err && err.code == errorCode
}

function prettyPrintSyntaxError(
  exception: WorkflowSyntaxError,
  inputFile: string,
  sourceCode: string,
): void {
  console.error(errorDisplay(inputFile, sourceCode, exception.location))
  console.error(`${exception.message}`)
}

function errorDisplay(
  filename: string,
  sourceCode: string,
  location: SourceCodeLocation | undefined,
): string {
  const lines: string[] = []
  const prettyFilename = filename === '-' ? '<stdin>' : filename
  if (
    typeof location?.start === 'undefined' ||
    typeof location?.end === 'undefined' ||
    isNaN(location?.start.line) ||
    isNaN(location?.end.line)
  ) {
    lines.push(`File ${prettyFilename}:`)
  } else {
    lines.push(
      `File ${prettyFilename}, line ${location.start.line}, column ${location.start.column + 1}:`,
    )
  }

  const highlightedLine = highlightedSourceCodeLine(
    sourceCode,
    location?.start?.line,
    location?.start?.column,
    location?.start?.line === location?.end?.line
      ? location?.end?.column
      : undefined,
  )
  if (highlightedLine.length > 0) {
    lines.push(highlightedLine)
    lines.push('')
  }

  return lines.join('\n')
}

function highlightedSourceCodeLine(
  sourceCode: string,
  lineNumber?: number,
  start?: number,
  end?: number,
): string {
  if (
    typeof lineNumber === 'undefined' ||
    typeof start === 'undefined' ||
    isNaN(start)
  ) {
    return ''
  }

  const lines = sourceCode.split('\n')
  const sourceLine = lines[lineNumber - 1]
  if (typeof sourceLine === 'undefined') {
    return ''
  }

  let markerLength
  if (typeof end === 'undefined') {
    markerLength = sourceLine.length - start
  } else {
    markerLength = Math.min(end - start + 1, sourceLine.length - start)
  }

  const markerLine = `${' '.repeat(start)}${'^'.repeat(markerLength)}`

  return `${sourceLine}\n${markerLine}`
}

function versionFromPackageJson(): string {
  const currentFile = fileURLToPath(import.meta.url)
  const currentDir = path.dirname(currentFile)
  const packagePath = path.join(currentDir, '..', 'package.json')
  const pjson = JSON.parse(fs.readFileSync(packagePath, 'utf-8')) as {
    version?: string
  }
  return pjson.version ?? '???'
}

if (
  import.meta.url.endsWith(process.argv[1]) ||
  process.argv[1].endsWith('/ts2workflows')
) {
  cliMain()
}
